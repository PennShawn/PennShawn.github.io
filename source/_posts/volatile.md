---
title: volatile
categories: 
 - 技术
tags:
 - Java
 - 多线程
---


##### JMM java内存模型
计算机在执行程序时,指令都是在cpu中执行的,cpu需要从主内存中读取数据.但是cpu的处理速度比主内存的操作快多了,所有cpu的外层就有了告诉缓存,L1、L2缓存.
在操作数据时,可以先把数据从主内存中读取到缓存中,在缓存中操作后,再更新到主内存中.

#### 并发编程需要注意的三个问题
##### 一、原子性
即使是volatile变量,`i++`也不是原子性的操作,因为它包含两条执行,加运算与赋值.如
```
i = 10;
i++;
```
有可能在线程A中,将i读取到缓存,然后获取++结果11;这时候B线程执行了,执行完了i++写到主内存中.这时候,A线程只剩下一个赋值操作`i=11;`,i又被赋值给了11.所以volatile是无法保证这种情况的原子性.可以使用AtomicInteger等线程安全的结构调用increAndGet等方法,这些方法会通过CAS来赋值,CAS又是通过处理器提供的CMPXCHG指令来保证操作的原子性.

##### 二、可见性
被volatile修饰的变量在进行写运算时,汇编后会加上后lock前缀.这个前缀通过以下两个途径保证可见性:
1. 写操作后,会把最新的结果更新到主内存
2. 写操作后,其它缓存中的volatile数据副本会失效
所以,在一个线程写操作后,其它线程要使用volatile变量需要重新从内存中读取最新的数据.

##### 三、有序性
jvm是会进行指令重排序来优化代码执行效率的,但是指令重排序也需要遵循happens-before原则,单线程情况下一般没有问题,但在多线程情况下可能会有并发问题.如:
```
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```
就有可能进行指令重排序导致没有初始化就执行后续代码.<br>
volatile关键字通过添加内存屏障来禁止指令重排序来保证有序性.

