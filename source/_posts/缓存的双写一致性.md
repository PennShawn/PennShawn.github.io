---
title: 缓存的双写一致性
categories: 
 - 技术
tags:
 - Java
 - redis
---

缓存能给程序的性能带来很高的提升,但是在更新缓存时,到底是先删除缓存,还是先更新数据库存在一些争议.

#### 先更新数据库,再更新缓存
这种操作很容易产生并发问题,比如:
```
线程A更新了数据库
线程B更新了数据库
线程B更新了缓存
线程A更新了缓存
```
造成的结果就是,数据库中是B的数据,缓存中是A的数据,这就产生了脏数据.

#### 先删除缓存,再更新数据库
这种操作在一些极端情况下也有问题
```
线程A删除了缓存
线程B读取了数据,并且把数据添加到缓存中
线程A修改了数据库
```
这时候,缓存里还是B再A修改之前读到的旧数据.
这个问题可以用**延时双删**解决,伪代码如下:
```
public void write(String key,Object data){
		redis.delKey(key);
	    db.updateData(data);
	    Thread.sleep(1000);
	    redis.delKey(key);
	}
```
但这样还是有例外情况,比如之后的删除操作由于异常没有执行成功.

#### 先更新数据库,再删除缓存
这种顺序在特别极端的时候也会有并发问题
```
缓存正好失效了
线程A发现缓存中没数据,去数据库读到了旧值
线程B更新数据库
线程B删除缓存
线程A将旧值读到缓存中
```
实际上这种情况非常难出现,可以看到它的条件有,A读缓存的耗时比B跟新数据再删除都要长,但一般情况下,数据库读的速度比写的速度快很多.

如果非要解决这个问题,也就是保证B删除缓存在A将旧值写入缓存之后,可以给B删除缓存加延迟.但是更极端的情况下B删除缓存可能会失败,这时候还有两种解决方案.
1. 用一个消息队列来进行删除操作.没删除成功的话,重复执行.这样做有一个问题,会对业务代码造成侵入.
2. 启动一个订阅程序去订阅数据库的binlog,获得需要操作的数据.在应用程序中,另起一段程序,获得这个订阅程序的传来的消息,进行删除缓存操作.
 ![image](http://note.youdao.com/yws/res/3455/A3BCF0F58B9043C29A23AC19AD5DD7FE)
流程如下图所示：
```
（1）更新数据库数据
（2）数据库会将操作信息写入binlog日志当中
（3）订阅程序提取出所需要的数据以及key
（4）另起一段非业务代码，获得该信息
（5）尝试删除缓存操作，发现删除失败
（6）将这些信息发送至消息队列
（7）重新从消息队列中获得该数据，重试操作。
```
上述的订阅binlog程序在mysql中有现成的中间件叫canal
