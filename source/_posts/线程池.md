---
title: 线程池
categories:
- 技术
tags:
- ThreadPool
- Java

---

---

## 线程池的创建

创建线程池时最好用`ThreadPoolExecutor`创建,其构造方法:
```
  public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```
常见的四种线程池也都是基于`ThreadPoolExecutor`创建的.

### 1.CachedThreadPool
```
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>(),
                                      threadFactory);
    }
```
corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE可以视为无穷大，workQueue是一个SynchronousQueue。SynchronousQueue可以认为是一个长度限制为0的队列，也就是向这个队列添加任务会永远是已满的状态。

由此可以得出通过该方法创建的线程池并不限制线程数量，每次添加的任务都会直接执行而不会放入workQueue，它的主要提供的功能是线程复用，但不能控制线程数量。

### 2.FixedThreadPool

```
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
创建一个大小固定为n的线程池

---
### 3.SingleThreadExecutor()
```
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```
workQueue是一个LinkedBlockingQueue<Runnabke>(),也就是认为队列的大小是Integer.MAX_VALUE,因此,可以提交多个任务,但是只能一个一个执行.

---
### 4.ScheduledThreadPool
```
    public static ScheduledExecutorService  newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```
![此处输入图片的描述][1]
DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的)

参考:JDK1.8
https://www.jianshu.com/p/925dba9f5969
https://www.jianshu.com/p/ade771d2c9c0

---
## 异常处理
线程池异常处理,虽然可以通过UncaughtExceptionHandler来实现默认的异常处理机制,但是,对于submit方法:
```
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
```
submit方法在调用execute之前,任务会通过`RunnableFuture<Void> ftask = newTaskFor(task, null);`封装,导致UncaughtExceptionHandler失效.
所以,还是得在线程里try..cache.

  [1]: https://upload-images.jianshu.io/upload_images/5401975-5b6acf02fe03ce68.png
