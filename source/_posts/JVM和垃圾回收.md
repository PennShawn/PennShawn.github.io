---
title: JVM和垃圾回收
categories: 
 - 技术
tags:
 - Java
 - JVM
---


JVM的内存空间可以分成堆、栈、本地方法区、本地方法栈和程序技术去


##### 堆
堆是JVM存放对象的地方,所有线程共享.堆有分为新生代和老年代,新生代可以分成eden区和servivor区,servicor区由可以分为S0,S1两个部分

新创建的对象一般会放到edne区里,然后垃圾回收时,没有被回收的对象放到S0或者S1中的一个,S0和S1的指责是交替的,这一次垃圾回收放进S0那么下一次垃圾回收就会筛选S0中的没有被回收的对象放进S1区里面,经过了已从次数的垃圾回收还没有被回收的对象就会进入老年代,一般默认是15次.


现在的JVM一半采用分代收集法,新生代和老年代的垃圾回收采用不同的算法.
新生代的特点是对象容易被回收,采用的垃圾回收算法是复制法,就是将eden区和from区的不会被存活的对象复制到to区,然后清理from区和eden区.

老年代的特点是数据不易被回收,采用的垃圾回收算法一般是标记整理法,先将要回收的对象进行标记,然后标记的对象和未标记的
对象向两端移动,之后清理标记的对象.这样做的好处是不会产生内存碎片.

一般来说,大的对象会直接存到老年代,像大数组之类的

通常,新生代会


##### 栈
栈是线程私有的,由方法栈帧组成的,用来记录方法调用关系,栈帧里面记录了局部变量和操作数等信息,如果方法调用太深,超出限制,会跑出StackOverFlow error,如果数据太多,会抛OOM error.

##### 方法区
方法区线程共享,又被称为"持久代"、“非堆 non-heap”,里面存放的数据是一些已经被虚拟机加载的类的信息、常量和静态变量等.GC一半不会影响到这里,但也不是会说这里面的数据不会被垃圾回收.当方法区空间不足时,也会抛OOM

##### 本地方法栈
和栈类似,线程私有,但是存放的是一写非java的本地方法的信息.也会抛stackOverFlow和OOM.

##### 程序技术器
线程私有的一小块内存,用于记录当前线程执行到字节码的行号,是JVM中唯一不会抛OOM的地方.



