---
title: JVM和垃圾回收
categories: 
 - 技术
tags:
 - Java
---


首先,我们都知道java是一种跨平台的语言,不止java,其它的JVM语言都有这种特性,主要原因就是,它们在运行前,都会被编译成.class字节码文件,这个字节码文件就是JVM能读懂的二进制文件.

#### JVM加载.class文件步骤
1. load
 
首先,是load字节码文件,把文件里定义的类的信息加载到放方法区,然后在堆里面生成一个Class对象,作为访问这个类的句柄.

2. check

这一步就是要检查这个.class文件是否符合JVM规法,比如格式、类型还有参数校验等.

3.prepare

这个阶段会给类中的字段赋上默认值,比如`int a =1`会先给a字段赋上0,给引用类型赋上null.真正的赋值在后面进行.

4.Resolution(解析)

这个阶段将常量池中的符号引用转换成直接引用,
符号引用相当于一个给JVM的字面量,不能代表引用的对象已经被加载到内存里了,只有转换成了直接引用才能说明目标被加载到了内存中.


5.初始化

这个阶段就是调用类构造器的clinit方法,这个方法会先判断父类有没有被加载,没有加载的话优先加载父类.也会先执行父类的静态语句,然后才会执行自己的静态语句.
之后才是调用init构造方法.


##### 3种类加载器
java自带了3中类加载器:
1. 启动类加载器 BootStrap ClassLoader
2. 扩展类加载器 ExtClassLoader
3. 应用程序类加载器 AppClassLoader
3种类加载器按上面的层级结构执行.

##### 双亲委派模型
一个类加载器收到委托时,会优先将委托提交给父类,依次向上传递,如果一个类加载器发现已经加载过这个类了,那么就不用重复加载了.比如A类依赖于System类,B类也依赖与System类,肯定不能加载两份System类到内存中,这时候双亲委派模型就可以保证,rt.jar下的System的加载请求只能由BootStrap Classloader执行,并且只执行一次.
