---
title: 强引用、软引用、弱引用和虚引用
categories: 
 - 技术
tags:
 - Java
---


#### 强引用
强引用是最常见的引用方式.对于`Object obj = ew Object()`这里obj所持有的就是强引用,jvm判断一个对象需不需要回收就是判断有没有指向它的引用,当强引用过多,内存空间不足时,jvm就会跑出oom错误.

#### 软引用
软引用是用来描述一些非必须但是仍有用的对象,当jvm内存足够的时候,软引用的对象不会被回收,只有在内存不足的时候,才会回收软引用的对象.

JVM分配内存空间时,会先判断内存空间是否足够,不够的话进行GC,GC后还不够的话,会再进行一次GC将,这时才会将软引用移除.所有软引用并不是GC的时候一定会被移除的.
```
https://www.jianshu.com/p/825cca41d962
/**
 * 软引用何时被收集
 * 运行参数 -Xmx200m -XX:+PrintGC
 * Created by ccr at 2018/7/14.
 */
public class SoftReferenceDemo {

    public static void main(String[] args) throws InterruptedException {
        //100M的缓存数据
        byte[] cacheData = new byte[100 * 1024 * 1024];
        //将缓存数据用软引用持有
        SoftReference<byte[]> cacheRef = new SoftReference<>(cacheData);
        //将缓存数据的强引用去除
        cacheData = null;
        System.out.println("第一次GC前" + cacheData);
        System.out.println("第一次GC前" + cacheRef.get());
        //进行一次GC后查看对象的回收情况
        System.gc();
        //等待GC
        Thread.sleep(500);
        System.out.println("第一次GC后" + cacheData);
        System.out.println("第一次GC后" + cacheRef.get());

        //在分配一个120M的对象，看看缓存对象的回收情况
        byte[] newData = new byte[120 * 1024 * 1024];
        System.out.println("分配后" + cacheData);
        System.out.println("分配后" + cacheRef.get());
    }

}

第一次GC前null
第一次GC前[B@7d4991ad
[GC (System.gc())  105728K->103248K(175104K), 0.0009623 secs]
[Full GC (System.gc())  103248K->103139K(175104K), 0.0049909 secs]
第一次GC后null
第一次GC后[B@7d4991ad
[GC (Allocation Failure)  103805K->103171K(175104K), 0.0027889 secs]
[GC (Allocation Failure)  103171K->103171K(175104K), 0.0016018 secs]
[Full GC (Allocation Failure)  103171K->103136K(175104K), 0.0089988 secs]
[GC (Allocation Failure)  103136K->103136K(199680K), 0.0009408 secs]
[Full GC (Allocation Failure)  103136K->719K(128512K), 0.0082685 secs]
分配后null
分配后null
```

这种特性就可以用来做缓存,因为缓存的存在是为了减少对数据库的查询,所以我们可以将查询到的数据存储在缓存中,但是,不能因为缓存数据太多导致OOM,这就得不偿失了.这时候就可以用软引用将数据缓存起来,内存实在是不够的时候就可以清理一批缓存了.


#### 弱引用
弱引用是用来描述非必须对象的,它的强度比软引用更弱一点,只要进行垃圾回收时,一个对象只被弱引用了,没有任何强引用或者软引用,那么这个对象就会被回收.
弱引用的使用场景:
```
static Map<Object,Object> container = new HashMap<>();
public static void putToContainer(Object key,Object value){
    container.put(key,value);
}

public static void main(String[] args) {
    //某个类中有这样一段代码
    Object key = new Object();
    Object value = new Object();
    putToContainer(key,value);

    //..........
    /**
     * 若干调用层次后程序员发现这个key指向的对象没有用了，
     * 为了节省内存打算把这个对象抛弃，然而下面这个方式真的能把对象回收掉吗？
     * 由于container对象中包含了这个对象的引用,所以这个对象不能按照程序员的意向进行回收.
     * 并且由于在程序中的任何部分没有再出现这个键，所以，这个键 / 值 对无法从映射中删除。
     * 很可能会造成内存泄漏。
     */
    key = null;
}
```
这种情况下就可以使用`WeakHashMap`来保存储存对象,如果一个对象只由WeakHashMap引用,找不到其他强一点的引用了,那么这个对象就会被放入等待垃圾回收的队列中.

我们项目中,由于Mina框架的问题,出现过内存泄漏的问题,玩家由于一些异常情况下线时,ioSession没有正确的被释放掉.mina在要移除一个session时,不是立刻移除,而是放在一个removingSessions容器中,然后Processor的run方法中会遍历这个容器,判断遍历到的容器的状态,如果session状态是closing则跳过移除.
```
/**
     * {@inheritDoc}
     */
    @Override
    public final void remove(S session) {
        scheduleRemove(session);
        startupProcessor();
    }

    private void scheduleRemove(S session) {
        if (!removingSessions.contains(session)) {
            removingSessions.add(session);
        }
    }

//在Processor的run方法中调用
  private int removeSessions() {
            int removedSessions = 0;

            for (S session = removingSessions.poll(); session != null; session = removingSessions.poll()) {
                SessionState state = getState(session);

                // Now deal with the removal accordingly to the session's state
                switch (state) {
                case OPENED:
                    // Try to remove this session
                    if (removeNow(session)) {
                        removedSessions++;
                    }

                    break;

                case CLOSING:
                    // Skip if channel is already closed
                    // In any case, remove the session from the queue
                    removedSessions++;
                    break;

                case OPENING:
                    // Remove session from the newSessions queue and
                    // remove it
                    newSessions.remove(session);

                    if (removeNow(session)) {
                        removedSessions++;
                    }

                    break;

                default:
                    throw new IllegalStateException(String.valueOf(state));
                }
            }

            return removedSessions;
        }

```
WriteBuffer时产生异常会调用destroy方法,造成session状态是closing,导致removingSessions中的session没有被移除,越堆越多.
```
try {
                    localWrittenBytes = write(session, buf, length);
                } catch (IOException ioe) {
                    ioe.printStackTrace();

                    // We have had an issue while trying to send data to the
                    // peer : let's close the session.
                    buf.free();
                    session.closeNow();
                    destroy(session);

                    return 0;
                }

```
解决方法是提升mina版本,mina已经修复了这个问题,异常时调用的是removeNow方法直接移除而不是destroy了,解决了内存泄漏的问题.
```
try {
                    localWrittenBytes = write(session, buf, length);
                } catch (IOException ioe) {
                    ioe.printStackTrace();

                    // We have had an issue while trying to send data to the
                    // peer : let's close the session.
                    buf.free();
                    session.closeNow();
                    this.removeNow(session);

                    return 0;
                }
```
但是,为了方便以后问题排查,可以把playersession保存在WeakHashMap中,如果正常移除最好,但是如果还有内存泄漏,那么就可以在WeakHashMap中找到palyerSession对象查看它的状态了.https://gitlabdoc.playcrab.com/kosserver/share/wikis/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F


#### 虚引用
虚引用和软引用、弱引用不同,它不影响对象的生命周期,一个兑现如果只有虚引用,那和没有被引用一样,任何时候都有可能被回收.虚引用必须搭配`ReferenceQueue`使用.
```
public class PhantomReference<T> extends Reference<T> {
    /**
     * Returns this reference object's referent.  Because the referent of a
     * phantom reference is always inaccessible, this method always returns
     * <code>null</code>.
     *
     * @return  <code>null</code>
     */
    public T get() {
        return null;
    }
    public PhantomReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
```
jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。

##### 引用队列
软引用、弱引用和虚引用都可以搭配引用队列ReferenceQueue一起使用.当JVM将要会后一个对象时,就会将对应的这些引用加入到与之关联的引用队列中,程序就可以通过引用队列中有没有该对象的引用,来判断该对象是否将要被回收.


https://www.cnblogs.com/liyutian/p/9690974.html
https://www.jianshu.com/p/825cca41d962
https://blog.csdn.net/linzhiqiang0316/article/details/88591907
