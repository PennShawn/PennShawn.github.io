---
title: 项目热更原理
categories: 
 - 技术
tags:
 - Java
---

在我们项目中,难免会有一些逻辑错误的代码发布到了线上.要修复这些问题,如果停服维护,修改代码后重启服务器的话玩家体验会非常差.这时候就可以进行热更,不重启服务器修改方法逻辑.


#### 原理
Java5之后引入了` java.lang.Instrument`包,允许我们在运行时动态的修改系统中Class的信息.
#### javaagent
javaagent是java命令的一个参数,可以用于指定一个jar包,这个jar包有两个要求:
1. 这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。
2. Premain-Class 指定的那个类必须实现 premain() 方法。
premain()方法顾名思义就是在main()方法执行前就会被调用
```
 public static Instrumentation instrumentation;

    public static void premain(String args, Instrumentation i) {
        System.out.println("premain");
        instrumentation = i;
    }
```
...
##### 如何使用javaagent
1. 定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。
2. 创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。
3. 将 premain 的类和 MANIFEST.MF 文件打成 jar 包。
4. 使用参数` -javaagent: jar包路径` 启动要代理的方法


Agent编写完之后，我们还需要定义MANIFEST.MF模板文件，并且在pom.xml中加入相应代码，让我们能在打包时生成Manifest。

pom.xml
```
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-jar-plugin</artifactId>
<configuration>
<archive>
<manifestFile>src/META-INF/MANIFEST.MF</manifestFile>
<manifest>
<addClasspath>true</addClasspath>
<classpathPrefix>lib/</classpathPrefix>
<mainClass>classloader.Main</mainClass>
</manifest>
</archive>
</configuration>
</plugin>
```
MANIFEST.MF
```
Manifest-Version: 1.0
Premain-Class: classloader.HotswapAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Can-Set-Native-Method-Prefix: true
Manifest的作用其实就是指定Agent类是谁，从而能够定位到premain方法。
```


#### 热更的逻辑
当我们线上的`service`层逻辑出了问题的时候,我们可以修改`service`类的方法逻辑,然后重启,更方便的方法就是修改逻辑后,将系统中的service类重新加载下.而`Instrument`就提供了`redefineClasses`方法.

##### 服务器怎么知道何时需要加载新的service类?
我们可以用在服务器中启动一个线程取监听`reload`文件夹,当reload文件夹中文件发生变化时,即要热更的类加到reload文件夹后,重新加载该类.
```
public enum ClassFileReader {
    INSTANCE;

    private String path;

    public byte[] readClassFile(String fileName) throws IOException {
        Path path = Paths.get(fileName);
        byte[] data = Files.readAllBytes(path);
        return data;
    }

    public void start(String path) throws IOException {
        this.path = path;
        WatchService watcher = FileSystems.getDefault().newWatchService();
        Path dir = Paths.get(path);
        dir.register(watcher, StandardWatchEventKinds.ENTRY_MODIFY);

        for (;;) {
            WatchKey key;
            try {
                key = watcher.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
                return;
            }

            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();
                if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                    String fileName = event.context().toString();
                    System.out.println("Path is modified:" + fileName);
                    if (fileName.endsWith(".class")) {
                        String className = fileName.substring(0, fileName.length() - 6);
                        System.out.println("reload className:" + className);
                        byte[] classContent = readClassFile(this.path + "/" + fileName);
                        System.out.println(new String(classContent));
                        try {
                            Class<?> clz = Class.forName(className);
                            HotSwapAgent.reload(clz, classContent);
                        } catch (ClassNotFoundException e) {
                            e.printStackTrace();
                            continue;
                        } catch (Exception e) {
                            e.printStackTrace();
                            continue;
                        }
                    }
                }
            }

            if (!key.reset()) {
                break;
            }
        }
    }
}
```
reload方法:
```
public static void reload(Class<?> clazz, byte[] data)
            throws UnmodifiableClassException, ClassNotFoundException {
        ClassDefinition classDefinition = new ClassDefinition(clazz, data);
        instrumentation.redefineClasses(new ClassDefinition[] { classDefinition });
    }
```

##### 整合到项目中
```
public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(1);
        ((ScheduledThreadPoolExecutor) threadPoolExecutor).scheduleAtFixedRate(new Runnable() {

            @Override
            public void run() {
                Service.print();
            }
        }, 30, 5, TimeUnit.SECONDS);

        //监听文件变化
        new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    ClassFileReader.INSTANCE.start("/Users/playcrab/Documents/reload");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();

    }
```
假如我们在项目中定时的调用Service的print方法,但是print的需求变了,我们就可以通过热更的方式实现修改方法逻辑.
```
 public static void print() {
        //System.out.println("origin");
        System.out.println("hotfixed");
    }
```


##### 效果
```
premain
origin
origin
origin
origin
origin
origin
origin
origin
origin
Path is modified:hotswap.Service.class
reload className:hotswap.Service
����4
	
<init>()VCodeLineNumberTableprint
SourceFileService.java	hotfixed2hotswap/Servicejava/lang/Objectjava/lang/SystemoutLjava/io/PrintStream;java/io/PrintStreamprintln(Ljava/lang/String;)V!	*��
		%	���


hotfixed2
hotfixed2
hotfixed2
hotfixed2
...
```


##### 总结
Instrument可以让我们在运行时动态的修改类的信息,我们可以监听热更事件并借助javaagent来实现热更.

参考: https://www.jianshu.com/p/0bbd79661080
