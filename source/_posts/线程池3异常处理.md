---
title: 线程池3 异常处理
categories:
- 技术
tags:
- ThreadPool
- Java
---

任务提交到线程池后,线程池会对线程进行封装,当线程抛异常的时候,如果我们在线程方法里面没有手动补货,并不会有打印输出.
AbstractExecutorService 中的submit()方法:如下
```
public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
```
我们的线程在submit后,会先被封装成FutureTask,FutureTask中的run方法实现如下:
```

    public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);     //  here!!!!!
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```
可以看到,在发生异常后,会调用` setException(ex); `
```
protected void setException(Throwable t) {
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            outcome = t;
            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
            finishCompletion();
        }
    }
```
即使我们最开始在创建线程task时,定义了默认的异常处理方法也不会执行.
```
    static class Task implements Runnable {
        @Override
        public void run() {
            Thread.currentThread()
                    .setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {

                        @Override
                        public void uncaughtException(Thread t, Throwable e) {
                            System.out.println("exception");
                        }
                    });

            System.out.println("---");
            System.out.println(1 / 0);
            System.out.println(Thread.currentThread().getName());

        }
    }
```
异常就这样被吞掉了.

#### 解决方法
##### 1.调用execute而不是submit
这样发生异常时会触发我们定义的异常处理方法

##### 2.Future.get()
```
 Future future =  cachedThreadPool.submit(task);
        future.get();
```
这样也可以得到异常信息,但只知道是哪里抛出的,而不知道哪里提交的.
```
Exception in thread "main" java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero
	at java.util.concurrent.FutureTask.report(FutureTask.java:122)
	at java.util.concurrent.FutureTask.get(FutureTask.java:192)
	at test.thread.SelfDefindPool.main(SelfDefindPool.java:65)
Caused by: java.lang.ArithmeticException: / by zero
	at test.thread.SelfDefindPool$Task.run(SelfDefindPool.java:83)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

##### 3.自己动手,改良一下线程池
```
 static class TraceThreadPoolExecutor extends ThreadPoolExecutor{

        public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
        }

        @Override
        public void execute(Runnable command) {
            super.execute(wrap(command,clientTrace()));
        }

        @Override
        public  Future<?> submit(Runnable task) {
            return super.submit(wrap(task,clientTrace()));
        }

        private Exception clientTrace(){
            return new Exception("Client stack trace");
        }

        private Runnable wrap(final Runnable task,final Exception clientStack){
            return new Runnable() {

                @Override
                public void run() {
                    try {
                        task.run();
                    }catch (Exception e){
                        clientStack.printStackTrace();
                        throw e;
                    }
                }
            };
        }
    }
```
对于每一个submit过来的线程,我们在run方法里面手动加上`try cache`,这样发生异常时,就能捕获异常并处理.异常输出如下:
```
java.lang.Exception: Client stack trace
	at test.thread.SelfDefindPool$TraceThreadPoolExecutor.clientTrace(SelfDefindPool.java:116)
	at test.thread.SelfDefindPool$TraceThreadPoolExecutor.submit(SelfDefindPool.java:112)
	at test.thread.SelfDefindPool.main(SelfDefindPool.java:68)
```
这里的68行就是submit方法的行数.

整体代码:
```
package test.thread;

import java.util.concurrent.*;

import com.alipay.remoting.NamedThreadFactory;

/**
 * @Description: 自定义线程池
 * @Author: shenpeng
 * @Date: 2019-04-04
 */
public class SelfDefindPool {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /**
         * cachedThreadPool
         */
        ExecutorService cachedThreadPool = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60,
                TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
                new NamedThreadFactory("CachedThread"), new ThreadPoolExecutor.AbortPolicy());

        int cpuNum = Runtime.getRuntime().availableProcessors();

        /**
         * fixedThreadPool
         */
        ExecutorService fixedThreadPool = new ThreadPoolExecutor(cpuNum + 1, cpuNum + 1, 0,
                TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),
                new NamedThreadFactory("FixedThread"), new ThreadPoolExecutor.AbortPolicy());

        /**
         * singleThreadPool
         */
        ExecutorService singleThreadPool = new ThreadPoolExecutor(1, 1, 0, TimeUnit.NANOSECONDS,
                new LinkedBlockingQueue<>(), new NamedThreadFactory("SingleThread"),
                new ThreadPoolExecutor.AbortPolicy());

        /**
         * scheduledThreadPool
         */
        ExecutorService scheduledThreadPool = new ThreadPoolExecutor(cpuNum + 1, Integer.MAX_VALUE,
                0, TimeUnit.NANOSECONDS, new DelayQueue(),
                new NamedThreadFactory("ScheduledThread"), new ThreadPoolExecutor.AbortPolicy());

        ScheduledThreadPoolExecutor scheduledExecutorService = new ScheduledThreadPoolExecutor(2,
                new NamedThreadFactory("schedule"), new ThreadPoolExecutor.AbortPolicy());

        Runnable task = new Task();
        /**
         * scheduleAtFixedRate 从上一次任务开始执行时 根据period计算下次开始执行时间
         */
        // scheduledExecutorService.scheduleAtFixedRate(task, 3, 4, TimeUnit.SECONDS);
        /**
         * scheduleWithFixedDelay 从上一次任务结束的时候 根据delay计算下次任务开始的执行时间
         */
        //scheduledExecutorService.scheduleWithFixedDelay(task, 3, 4, TimeUnit.SECONDS);
        try {
        //    scheduledExecutorService.scheduleWithFixedDelay(task, 1, 1, TimeUnit.SECONDS);

        } catch (Exception e) {
            System.out.println(11);
        }

//        Future future =  cachedThreadPool.submit(task);
//        future.get();

        ExecutorService threadPool = new TraceThreadPoolExecutor(2, 2, 1, TimeUnit.SECONDS,new LinkedBlockingDeque<>(),new NamedThreadFactory("myThreadPool"));
        threadPool.submit(task);
    }

    static class Task implements Runnable {

        @Override
        public void run() {
            Thread.currentThread()
                    .setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {

                        @Override
                        public void uncaughtException(Thread t, Throwable e) {
                            System.out.println("exception");
                        }
                    });

            System.out.println("---");
            System.out.println(1 / 0);
//            try {
//            System.out.println(1 / 0);
//            }catch (Exception e){
//                System.out.println("error");
//               // e.printStackTrace();
//                throw e;
//            }
            System.out.println(Thread.currentThread().getName());

        }
    }

    static class TraceThreadPoolExecutor extends ThreadPoolExecutor{

        public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
        }

        @Override
        public void execute(Runnable command) {
            super.execute(wrap(command,clientTrace()));
        }

        @Override
        public  Future<?> submit(Runnable task) {
            return super.submit(wrap(task,clientTrace()));
        }

        private Exception clientTrace(){
            return new Exception("Client stack trace");
        }

        private Runnable wrap(final Runnable task,final Exception clientStack){
            return new Runnable() {

                @Override
                public void run() {
                    try {
                        task.run();
                    }catch (Exception e){
                        clientStack.printStackTrace();
                        throw e;
                    }
                }
            };
        }
    }

}
```

