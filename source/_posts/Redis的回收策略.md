---
title: Redis的回收策略
categories: 
 - 技术
tags:
 - Java
 - redis
---

Redis的内存回收可以分成两部分:过期键的删除和内存溢出时的控制策略.

#### 1.过期键的删除
redis所有的键都可以设置过期时间,这些设置了过期时间的键被保存在一个字典中.如果要精准的维护每个键,这对于单线程的redis来说成本过高.因此,redis采用**惰性删除**和**定期任务删除**两种方式来进行过期键的内存回收.

##### 惰性删除
惰性删除是一种被动的删除策略,当客户端请求一个带有过期时间的键的时候,先判断键有没有过期,过期了就把这个键删除,返回空;没有过期则正常返回.这样做能够节省CPU成本,但是单独使用这个策略会有内存泄漏的问题,没有被访问过的过期键会一直得不到删除,所以一般得配合定期任务删除策略来使用.

##### 定期任务删除
定期任务删除是指在redis内部维护一个定时任务,默认是每秒10次(可以配置),随机检查一定数量的key比如20个,删除其中过期的key,如果过期的key占抽样数量的25%以上,那么重复执行上一次.

#### 2.内存溢出时控制策略
当redis的内存达到maxmemory后会触发相应的内存溢出策略,具体策略受maxmemory-policy控制
- noeviction: 默认策略,当内存不足以容纳新写的数据时,写入操做会报错.
- allkeys-lru: 当内存不足以容纳新写入的数据时,会移除最近最少使用的key.推荐使用,目前的项目在用这种.
- keys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。

参考 https://www.jianshu.com/p/6a5eb0ddf57b

